'''
函数也是一个对象
函数中保存一些可以指向的代码，别且在需要时，可以对这些语句多次调用
def 函数名([形参1,形参2....]):
    代码块
函数中保存的代码不会立即指向，需要用 函数名() 调用

'''
def alert():
    print('你好')
alert()
print(alert) #打印函数的内存地址 <function alert at 0x0000021172030680>
print(type(alert))#<class 'function'>
print(id(alert))#2273950500480
'''
在定义函数时，可以在函数名后面指定形参，可以有也可以没有
定义形参就相当于在函数内部声明了x1,x2...=none,none
如果在定义函数时定义了形参则，必须传入对等数量的实参

'''

#alert是函数对象，alert()调用函数
def add(a,b):
    return a+b
print(add(1921,1212))
#可以形参定义默认值,如果用户没有传递值，则默认值就会生效
def add1(a=10,b=20):
    return a+b
print(add1())
#实参的传递方式
#   -位置参数:将对应位置的实参传递给形参
#   -关键字参数:不按照形参定义的顺序传递，而是根据参数名去传递参数
#   -混合使用位置参数和关键字参数时，必须将位置参数写到前面
#   -函数在调用时，解析器不会检查实参的类型,实参可以传递任意类型的对象

def add1(a,b=10):
    return a+b
print(add1(10))

'''
在函数中对形参进行重新赋值，不会影响其他变量。
但如果函数中对一个对象进行操作(比如lis0[0]=1)会影响所有指向该对象的变量
此时可以通过copy()进行浅复制来避免这种影响,或者使用[:]来拷贝一个列表的副本(等同于.copy())

'''
a=[200,100]
def add3(a):
    a[0]=100
# add3(a)
add3(a.copy())
print(a)

'''
不定长参数
    -在定义函数时，在形参前面加上*可以将所有的实参保存到元组中,带*的形参只能有一个
    -带*的参数可以和其他参数配合使用
    -带*的参数不是必须写在最后,如果不写在最后，那么在*参数只会的参数只能使用关键字方式传递
    -如果在定义函数开头写一个*,x1,x2则表示只能用关键字传递实参
    -带*的参数只能接受位置实参，如果只接受关键字实参则会报错
    
    
    -带**形参可以接收未定义不定长的关键字参数，他会将这些参数保存到一个字典中
    字典的key就是参数的名字，字典的value就是参数的值
    -带**的形参只能有一个,且必须写在最后。
'''
def add4(a,*b,c,d):
    sum=0
    for i in b:
        sum+=i
    return sum+a+c+d

print(add4(1,2,3,4,5,6,c=10,d=20))

def add5(a,b,**c):
    return a+b+c['num']
print(add5(1,2,num=100))

'''
参数的解包
'''
def fun0(a,b,c):
    print(f'{a},{b},{c}')

tup0=(10,20,30)
dic0={'a':100,'b':200,'c':300}
#在传递实参时可以在序列类型的参数前面加上*号，这样会自动的将序列中的元素依次作为参数传递。
#序列中的个数需要和形参个数对应
fun0(*tup0)
#通过**来对字典进行解包,字典中的key必须和items数要和形参对应
fun0(**dic0)